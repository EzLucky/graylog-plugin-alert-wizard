package com.airbus_cyber_security.graylog.alert.utilities;

import com.airbus_cyber_security.graylog.alert.*;
import com.airbus_cyber_security.graylog.alert.rest.models.requests.AlertRuleRequest;
import com.airbus_cyber_security.graylog.alert.rest.models.responses.GetDataAlertRule;
import com.airbus_cyber_security.graylog.config.LoggingAlertConfig;
import com.airbus_cyber_security.graylog.config.LoggingNotificationConfig;
import com.airbus_cyber_security.graylog.config.SeverityType;
import com.airbus_cyber_security.graylog.events.processor.aggregation.AggregationCountProcessorConfig;
import com.airbus_cyber_security.graylog.events.processor.correlation.CorrelationCountProcessorConfig;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import org.apache.commons.lang3.RandomStringUtils;
import org.bson.types.ObjectId;
import org.graylog.events.conditions.Expr;
import org.graylog.events.conditions.Expression;
import org.graylog.events.notifications.EventNotificationHandler;
import org.graylog.events.notifications.EventNotificationSettings;
import org.graylog.events.notifications.NotificationDto;
import org.graylog.events.notifications.NotificationResourceHandler;
import org.graylog.events.processor.EventDefinitionDto;
import org.graylog.events.processor.EventDefinitionHandler;
import org.graylog.events.processor.EventProcessorConfig;
import org.graylog.events.processor.aggregation.AggregationConditions;
import org.graylog.events.processor.aggregation.AggregationEventProcessorConfig;
import org.graylog.events.processor.aggregation.AggregationFunction;
import org.graylog.events.processor.aggregation.AggregationSeries;
import org.graylog.events.rest.EventDefinitionsResource;
import org.graylog.events.rest.EventNotificationsResource;
import org.graylog.plugins.pipelineprocessor.db.*;
import org.graylog.plugins.pipelineprocessor.rest.PipelineConnections;
import org.graylog2.alarmcallbacks.AlarmCallbackConfiguration;
import org.graylog2.alarmcallbacks.AlarmCallbackConfigurationImpl;
import org.graylog2.alarmcallbacks.AlarmCallbackConfigurationService;
import org.graylog2.alarmcallbacks.AlarmCallbackFactory;
import org.graylog2.alerts.Alert;
import org.graylog2.alerts.AlertService;
import org.graylog2.configuration.HttpConfiguration;
import org.graylog2.database.NotFoundException;
import org.graylog2.events.ClusterEventBus;
import org.graylog2.lookup.LookupDefaultMultiValue;
import org.graylog2.lookup.LookupDefaultSingleValue;
import org.graylog2.lookup.adapters.HTTPJSONPathDataAdapter;
import org.graylog2.lookup.caches.NullCache;
import org.graylog2.lookup.db.DBCacheService;
import org.graylog2.lookup.db.DBDataAdapterService;
import org.graylog2.lookup.db.DBLookupTableService;
import org.graylog2.lookup.dto.CacheDto;
import org.graylog2.lookup.dto.DataAdapterDto;
import org.graylog2.lookup.dto.LookupTableDto;
import org.graylog2.plugin.Tools;
import org.graylog2.plugin.alarms.AlertCondition;
import org.graylog2.plugin.alarms.callbacks.AlarmCallbackConfigurationException;
import org.graylog2.plugin.cluster.ClusterConfigService;
import org.graylog2.plugin.configuration.ConfigurationException;
import org.graylog2.plugin.database.ValidationException;
import org.graylog2.plugin.streams.Stream;
import org.graylog2.plugin.streams.StreamRule;
import org.graylog2.rest.models.alarmcallbacks.requests.CreateAlarmCallbackRequest;
import org.graylog2.rest.models.streams.alerts.requests.CreateConditionRequest;
import org.graylog2.rest.resources.streams.requests.CreateStreamRequest;
import org.graylog2.streams.StreamImpl;
import org.graylog2.streams.StreamRuleImpl;
import org.graylog2.streams.StreamRuleService;
import org.graylog2.streams.StreamService;
import org.graylog2.streams.events.StreamDeletedEvent;
import org.graylog2.streams.events.StreamsChangedEvent;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.BadRequestException;
import java.util.*;

public class AlertRuleUtilsService {

    private static final Logger LOG = LoggerFactory.getLogger(AlertRuleUtilsService.class);

    private static final String ERROR_ALARM_CONDITION_CONFIGURATION = "Invalid alarm Condition configuration.";
    public static final String ERROR_ALARM_CALLBACK_CONFIGURATION = "Invalid alarm callback configuration.";
    private static final String ERROR_ALARM_CALLBACK_TYPE = "Invalid alarm callback type.";

    private static final String DESCRIPTION = "Generated by the wizard";

    private static final String RANDOM_CHARS = "0123456789abcdef";
    private static final int RANDOM_COUNT = 24;

    private final AlertRuleService alertRuleService;
    private final StreamService streamService;
    private final StreamRuleService streamRuleService;
    private final ClusterEventBus clusterEventBus;
    private final AlertService alertService;
    private final AlarmCallbackConfigurationService alarmCallbackConfigurationService;
    private final AlarmCallbackFactory alarmCallbackFactory;
    private final ClusterConfigService clusterConfigService;
    private final String indexSetID;
    private final AlertRuleUtils alertRuleUtils;
    private final RuleService ruleService;
    private final PipelineService pipelineService;
    private final DBDataAdapterService dbDataAdapterService;
    private final HttpConfiguration httpConfiguration;
    private final DBCacheService dbCacheService;
    private final DBLookupTableService dbTableService;
    private final PipelineStreamConnectionsService pipelineStreamConnectionsService;
    private final EventDefinitionsResource eventDefinitionsResource;
    private final EventNotificationsResource eventNotificationsResource;
    private final NotificationResourceHandler notificationResourceHandler;
    private final EventDefinitionHandler eventDefinitionHandler;

    public AlertRuleUtilsService(AlertRuleService alertRuleService,
                                 StreamService streamService,
                                 StreamRuleService streamRuleService,
                                 ClusterEventBus clusterEventBus,
                                 String indexSetID,
                                 AlertService alertService,
                                 AlarmCallbackConfigurationService alarmCallbackConfigurationService,
                                 AlarmCallbackFactory alarmCallbackFactory,
                                 ClusterConfigService clusterConfigService,
                                 RuleService ruleService,
                                 PipelineService pipelineService,
                                 DBDataAdapterService dbDataAdapterService,
                                 HttpConfiguration httpConfiguration,
                                 DBCacheService dbCacheService,
                                 DBLookupTableService dbTableService,
                                 PipelineStreamConnectionsService pipelineStreamConnectionsService,
                                 AlertRuleUtils alertRuleUtils,
                                 EventDefinitionsResource eventDefinitionsResource,
                                 EventNotificationsResource eventNotificationsResource,
                                 NotificationResourceHandler notificationResourceHandler,
                                 EventDefinitionHandler eventDefinitionHandler) {
        this.alertRuleService = alertRuleService;
        this.streamService = streamService;
        this.streamRuleService = streamRuleService;
        this.clusterEventBus = clusterEventBus;
        this.alertService = alertService;
        this.alarmCallbackConfigurationService = alarmCallbackConfigurationService;
        this.alarmCallbackFactory = alarmCallbackFactory;
        this.clusterConfigService = clusterConfigService;
        this.indexSetID = indexSetID;
        this.ruleService = ruleService;
        this.pipelineService = pipelineService;
        this.dbDataAdapterService = dbDataAdapterService;
        this.httpConfiguration = httpConfiguration;
        this.dbCacheService = dbCacheService;
        this.dbTableService = dbTableService;
        this.alertRuleUtils = alertRuleUtils;
        this.pipelineStreamConnectionsService = pipelineStreamConnectionsService;
        this.eventDefinitionsResource = eventDefinitionsResource;
        this.eventNotificationsResource = eventNotificationsResource;
        this.notificationResourceHandler = notificationResourceHandler;
        this.eventDefinitionHandler = eventDefinitionHandler;
    }

    public void checkIsValidRequest(AlertRuleRequest request){
        if(!alertRuleService.isValidRequest(request)){
            LOG.error("Invalid alert rule request");
            throw new BadRequestException("Invalid alert rule request.");
        }
    }

    private int countAlerts(String streamID, DateTime since){
        final List<Alert> alerts = alertService.loadRecentOfStream(streamID, since, 999);
        return alerts.size();
    }

    public void createStreamRule(List<FieldRuleImpl> listfieldRule, String streamID) throws ValidationException {
        for (FieldRule fieldRule:listfieldRule) {
            if (fieldRule.getType() != -7 && fieldRule.getType() != 7) {
                final Map<String, Object> streamRuleData = Maps.newHashMapWithExpectedSize(6);

                if (fieldRule.getType() >= 0) {
                    streamRuleData.put(StreamRuleImpl.FIELD_TYPE, fieldRule.getType());
                    streamRuleData.put(StreamRuleImpl.FIELD_INVERTED, false);
                } else {
                    streamRuleData.put(StreamRuleImpl.FIELD_TYPE, Math.abs(fieldRule.getType()));
                    streamRuleData.put(StreamRuleImpl.FIELD_INVERTED, true);
                }
                streamRuleData.put(StreamRuleImpl.FIELD_FIELD, fieldRule.getField());
                streamRuleData.put(StreamRuleImpl.FIELD_VALUE, fieldRule.getValue());
                streamRuleData.put(StreamRuleImpl.FIELD_STREAM_ID, new ObjectId(streamID));
                streamRuleData.put(StreamRuleImpl.FIELD_DESCRIPTION, AlertRuleUtils.COMMENT_ALERT_WIZARD);

                final StreamRule newStreamRule = streamRuleService.create(streamRuleData);
                streamRuleService.save(newStreamRule);
            }
        }
    }

    public String createStringField(FieldRule fieldRule, String condition) {
        return "  (has_field(\"" + fieldRule.getField() + "\")" + condition + "contains(to_string(lookup_value(\"wizard_lookup\", \"" +
                fieldRule.getValue() + "\", \"\")), to_string($message." + fieldRule.getField() + "), true))\n";
    }

    public String createRuleSource(String alertTitle, List<FieldRuleImpl> listfieldRule, Stream stream){
        StringBuilder fields = new StringBuilder();

        int nbList = 0;
        for (FieldRule fieldRule : listfieldRule) {
            if (fieldRule.getType() == 7 || fieldRule.getType() == -7){
                if( nbList > 0) {
                    fields.append("  ");
                    fields.append(stream.getMatchingType());
                }
                nbList++;
                if (fieldRule.getType() == 7) {
                    fields.append(createStringField(fieldRule, " AND "));
                } else {
                    fields.append(createStringField(fieldRule, " AND NOT "));
                }
            }
        }

        return "rule \"function " + alertTitle + "\"\nwhen\n" + fields + "then\n  route_to_stream(\"" + alertTitle + "\", \"" + stream.getId() + "\");\nend";
    }

    public RuleDao createPipelineRule(String alertTitle, List<FieldRuleImpl> listfieldRule, Stream stream, String ruleID) {

        final DateTime now = DateTime.now(DateTimeZone.UTC);

        if (ruleID == null) {
            ruleID = RandomStringUtils.random(RANDOM_COUNT, RANDOM_CHARS);
        }
        final RuleDao cr = RuleDao.create(ruleID, "function "+alertTitle, AlertRuleUtils.COMMENT_ALERT_WIZARD, createRuleSource(alertTitle, listfieldRule, stream), now, now);

        final RuleDao save = ruleService.save(cr);

        LOG.debug("Created new rule {}", save);
        return save;
    }

    public String createPipelineStringSource(String alertTitle, String matchingType) {
        String match;
        if (matchingType.equals("OR")){
            match="either";
        }else{
            match="all";
        }
        return "pipeline \""+alertTitle+"\"\nstage 0 match "+match+"\nrule \"function "+alertTitle+"\"\nend";
    }

    public PipelineDao createPipeline(String alertTitle, String pipelineID, String matchingType) {

        final DateTime now = DateTime.now(DateTimeZone.UTC);

        if (pipelineID == null) {
            pipelineID = RandomStringUtils.random(RANDOM_COUNT, RANDOM_CHARS);
        }
        final PipelineDao cr = PipelineDao.create(pipelineID, alertTitle, AlertRuleUtils.COMMENT_ALERT_WIZARD, createPipelineStringSource(alertTitle, matchingType), now, now);
        final PipelineDao save = pipelineService.save(cr);

        Set<String> pipelineIds;
        try {
            pipelineIds = pipelineStreamConnectionsService.load("000000000000000000000001").pipelineIds();
        } catch (NotFoundException e) {
            pipelineIds =  new HashSet<>();
        }
        pipelineIds.add(save.id());
        pipelineStreamConnectionsService.save(PipelineConnections.create(null, "000000000000000000000001", pipelineIds));

        LOG.debug("Created new pipeline {}", save);
        return save;
    }

    public void updatePipeline(Stream stream, List<FieldRuleImpl> listfieldRule, PipelineDao pipeline, String alertTitle, RuleDao rule) {

        pipelineService.delete(pipeline.id());
        ruleService.delete(rule.id());

        createPipeline(alertTitle, pipeline.id(), stream.getMatchingType().toString());
        createPipelineRule(alertTitle, listfieldRule, stream, rule.id());
    }

    public void deletePipeline(PipelineDao pipeline, RuleDao rule) {

        pipelineService.delete(pipeline.id());
        ruleService.delete(rule.id());
    }

    public Stream createStream(AlertRuleStream alertRuleStream, String title, String userName) throws ValidationException {

        final CreateStreamRequest cr = CreateStreamRequest.create(title, AlertRuleUtils.COMMENT_ALERT_WIZARD,
                Collections.emptyList(), "", alertRuleStream.getMatchingType(), false, indexSetID);
        final Stream stream = streamService.create(cr, userName);
        stream.setDisabled(false);

        if (!stream.getIndexSet().getConfig().isWritable()) {
            throw new BadRequestException("Assigned index set must be writable!");
        }
        final String streamID = streamService.save(stream);

        // Create stream rules.
        createStreamRule(alertRuleStream.getFieldRules(), streamID);

        return stream;
    }

    public Stream createOrUpdateSecondStream(AlertRuleStream alertRuleStream, String title, String userName, String conditionType, AlertRule oldAlert) throws ValidationException, NotFoundException {
        if(conditionType.equals("THEN") || conditionType.equals("AND") || conditionType.equals("OR")) {
            if(oldAlert.getSecondStreamID() != null) {
                Stream stream2 = streamService.load(oldAlert.getSecondStreamID());
                updateStream(stream2, alertRuleStream, title+"#2");
                // If request condition is not "OR" and the old one is "OR" remove stream condition and notification
                if(!conditionType.equals("OR") && oldAlert.getConditionType().equals("OR")) {
                    removeConditionAndNotificationFromStream(stream2);
                }
                return stream2;
            }else {
                return createStream(alertRuleStream, title+"#2", userName);
            }
        //Delete old stream if one
        }else if(oldAlert.getSecondStreamID() != null && !oldAlert.getSecondStreamID().isEmpty()) {
            deleteStreamFromID(oldAlert.getSecondStreamID());
        }
        return null;
    }

    public void updateStream(Stream stream, AlertRuleStream alertRuleStream, String title) throws ValidationException {

        stream.setTitle(title);
        if (alertRuleStream.getMatchingType() != null) {
            try {
                stream.setMatchingType(Stream.MatchingType.valueOf(alertRuleStream.getMatchingType()));
            } catch (IllegalArgumentException e) {
                throw new BadRequestException("Invalid matching type '" + alertRuleStream.getMatchingType()
                        + "' specified. Should be one of: " + Arrays.toString(Stream.MatchingType.values()));
            }
        }
        streamService.save(stream);

        //TODO do it better (don't destroy if update)
        // Destroy existing stream rules
        for (StreamRule streamRule:stream.getStreamRules()) {
            streamRuleService.destroy(streamRule);
        }
        // Create stream rules.
        createStreamRule(alertRuleStream.getFieldRules(), stream.getId());

        clusterEventBus.post(StreamsChangedEvent.create(stream.getId()));
    }

    public String updateCondition(Stream stream, AlertCondition oldAlertCondition, String title, String alertRuleCondType,
                                  Map<String, Object> alertRuleCondParameters, String streamID2, String userName) throws ValidationException {
        String alertConditionID = oldAlertCondition.getId();
        String conditionType = alertRuleUtils.getGraylogConditionType(alertRuleCondType);
        Map<String, Object> parameters = alertRuleUtils.getConditionParameters(streamID2, alertRuleCondType, alertRuleCondParameters);
        try {
            CreateConditionRequest ccr = CreateConditionRequest.create(conditionType , title, parameters);
            //If same condition type update
            if(oldAlertCondition.getType().equals(conditionType)) {
                final AlertCondition updatedCondition = alertService.updateFromRequest(oldAlertCondition, ccr);
                streamService.updateAlertCondition(stream, updatedCondition);
            }else {
                streamService.removeAlertCondition(stream, alertConditionID);
                final AlertCondition newAlertCondition = alertService.fromRequest(ccr, stream, userName);
                streamService.addAlertCondition(stream, newAlertCondition);
                alertConditionID = newAlertCondition.getId();
            }
        } catch (ConfigurationException e) {
            throw new BadRequestException("Invalid alert condition parameters", e);
        }
        return alertConditionID;
    }

    public  Stream cloneStream(Stream sourceStream, String newTitle, String creatorUser) throws ValidationException {
        // Create stream.
        final Map<String, Object> streamData = Maps.newHashMap();
        streamData.put(StreamImpl.FIELD_TITLE, newTitle);
        streamData.put(StreamImpl.FIELD_DESCRIPTION, AlertRuleUtils.COMMENT_ALERT_WIZARD);
        streamData.put(StreamImpl.FIELD_CREATOR_USER_ID, creatorUser);
        streamData.put(StreamImpl.FIELD_CREATED_AT, Tools.nowUTC());
        streamData.put(StreamImpl.FIELD_MATCHING_TYPE, sourceStream.getMatchingType().toString());
        streamData.put(StreamImpl.FIELD_REMOVE_MATCHES_FROM_DEFAULT_STREAM, sourceStream.getRemoveMatchesFromDefaultStream());
        streamData.put(StreamImpl.FIELD_INDEX_SET_ID, indexSetID);

        final Stream stream = streamService.create(streamData);
        stream.setDisabled(false);

        final String streamID = streamService.save(stream);

        final List<StreamRule> sourceStreamRules = streamRuleService.loadForStream(sourceStream);
        for (StreamRule streamRule : sourceStreamRules) {
            final Map<String, Object> streamRuleData = Maps.newHashMapWithExpectedSize(6);

            streamRuleData.put(StreamRuleImpl.FIELD_TYPE, streamRule.getType().toInteger());
            streamRuleData.put(StreamRuleImpl.FIELD_FIELD, streamRule.getField());
            streamRuleData.put(StreamRuleImpl.FIELD_VALUE, streamRule.getValue());
            streamRuleData.put(StreamRuleImpl.FIELD_INVERTED, streamRule.getInverted());
            streamRuleData.put(StreamRuleImpl.FIELD_STREAM_ID, new ObjectId(streamID));
            streamRuleData.put(StreamRuleImpl.FIELD_DESCRIPTION, streamRule.getDescription());

            final StreamRule newStreamRule = streamRuleService.create(streamRuleData);
            streamRuleService.save(newStreamRule);
        }
        return stream;
    }

    private void deleteStream(Stream stream){
        try {
            if(stream != null) {
                streamService.destroy(stream);
                clusterEventBus.post(StreamsChangedEvent.create(stream.getId()));
                clusterEventBus.post(StreamDeletedEvent.create(stream.getId()));
            }
        } catch (NotFoundException e) {
            LOG.error("Cannot find the stream ", e);
        }
    }

    public void deleteStreamFromID(String streamID){
        try{
            deleteStream(streamService.load(streamID));
        }catch(NotFoundException e){
            LOG.error("Cannot find the stream ", e);
        }
    }

    public void cleanAlertRule(Stream mainStream, Stream secondStream) {
        deleteStream(mainStream);
        deleteStream(secondStream);
    }

    private String mapAggregationFunctionToType(String aggregationFunction){
        switch (aggregationFunction) {
            case "AVG": return "MEAN";
            default:
                return aggregationFunction;
        }
    }

    public GetDataAlertRule constructDataAlertRule(AlertRule alert) throws NotFoundException {
        final String streamID = alert.getStreamID();
        final Stream stream = streamService.load(streamID);

        //Get the event
        EventDefinitionDto event = eventDefinitionsResource.get(alert.getEventID());
        LOG.info("Event type: " + event.config().type());

        Map<String, Object> parametersCondition = Maps.newHashMap();
        if(event.config().type().equals("aggregation-count")) {
            AggregationCountProcessorConfig aggregationCountConfig = (AggregationCountProcessorConfig) event.config();
            parametersCondition.put("threshold", aggregationCountConfig.threshold());
            parametersCondition.put("threshold_type", aggregationCountConfig.thresholdType());
            parametersCondition.put("time", aggregationCountConfig.searchWithinMs() / 60 / 1000);
            parametersCondition.put("grouping_fields", aggregationCountConfig.groupingFields());
            parametersCondition.put("distinction_fields", aggregationCountConfig.distinctionFields());
        }else if(event.config().type().equals("correlation-count")) {
            CorrelationCountProcessorConfig correlationConfig = (CorrelationCountProcessorConfig) event.config();
            parametersCondition.put("threshold", correlationConfig.threshold());
            parametersCondition.put("threshold_type", correlationConfig.thresholdType());
            parametersCondition.put("additional_threshold", correlationConfig.threshold());
            parametersCondition.put("additional_threshold_type", correlationConfig.thresholdType());
            parametersCondition.put("time", correlationConfig.searchWithinMs() / 60 / 1000);
            parametersCondition.put("grouping_fields", correlationConfig.groupingFields());
        }else if(event.config().type().equals("aggregation-v1")){
            AggregationEventProcessorConfig aggregationConfig = (AggregationEventProcessorConfig) event.config();
            LOG.info("Expr: "+ aggregationConfig.conditions().get().expression().get().expr());
            LOG.info("type: "+ aggregationConfig.series().get(0).function().toString());
            LOG.info("field: "+ aggregationConfig.series().get(0).field().get());
            LOG.info("threshold: "+ aggregationConfig.conditions().get().expression().get());

            parametersCondition.put("time", aggregationConfig.searchWithinMs() / 60 / 1000);
            parametersCondition.put("threshold", 0);
            parametersCondition.put("threshold_type", aggregationConfig.conditions().get().expression().get().expr());
            parametersCondition.put("type", mapAggregationFunctionToType(aggregationConfig.series().get(0).function().toString()));
            parametersCondition.put("field", aggregationConfig.series().get(0).field().get());
        }

        List<FieldRuleImpl> fieldRules = new ArrayList<>();
        Optional.ofNullable(alert.getPipelineFieldRules()).ifPresent(fieldRules::addAll);
        Optional.ofNullable(alertRuleUtils.getListFieldRule(stream.getStreamRules())).ifPresent(fieldRules::addAll);
        AlertRuleStream alertRuleStream = AlertRuleStreamImpl.create(streamID, stream.getMatchingType().toString(), fieldRules);

        AlertRuleStream alertRuleStream2 = null;
        if(alert.getSecondStreamID() != null && !alert.getSecondStreamID().isEmpty()) {
            final Stream stream2 = streamService.load(alert.getSecondStreamID());
            List<FieldRuleImpl> fieldRules2 = new ArrayList<>();
            Optional.ofNullable(alert.getSecondPipelineFieldRules()).ifPresent(fieldRules2::addAll);
            Optional.ofNullable(alertRuleUtils.getListFieldRule(stream2.getStreamRules())).ifPresent(fieldRules2::addAll);
            alertRuleStream2 = AlertRuleStreamImpl.create(alert.getSecondStreamID(), stream2.getMatchingType().toString(), fieldRules2);
        }

        LoggingNotificationConfig loggingNotificationConfig = (LoggingNotificationConfig) eventNotificationsResource.get(alert.getNotificationID()).config();
        LOG.info("Severity: " + loggingNotificationConfig.severity().getType());

        return GetDataAlertRule.create(alert.getTitle(), event.title(),
                loggingNotificationConfig.severity().getType(),
                alert.getEventID(),
                alert.getNotificationID(),
                alert.getCreatedAt(),
                alert.getCreatorUserId(),
                alert.getLastModified(),
                stream.getDisabled(),
                alert.getDescription(),
                countAlerts(streamID, alert.getLastModified()),
                alert.getConditionType(),
                parametersCondition,
                alertRuleStream,
                alertRuleStream2);
    }

    private void removeConditionFromStream(Stream stream) {
        List <AlertCondition> listAlertCondition = streamService.getAlertConditions(stream);
        if(listAlertCondition != null && !listAlertCondition.isEmpty()) {
            for (AlertCondition alertCondition : listAlertCondition) {
                streamService.removeAlertCondition(stream, alertCondition.getId());
            }
        }
    }
    public void removeNotificationFromStream(Stream stream) {
        List <AlarmCallbackConfiguration> listAlarmCallbackConfiguration = alarmCallbackConfigurationService.getForStream(stream);
        if(listAlarmCallbackConfiguration != null && !listAlarmCallbackConfiguration.isEmpty()) {
            for (AlarmCallbackConfiguration alarmCallbackConfiguration : listAlarmCallbackConfiguration) {
                alarmCallbackConfigurationService.destroy(alarmCallbackConfiguration);
            }
        }
    }
    public void removeConditionAndNotificationFromStream(Stream stream) {
        removeConditionFromStream(stream);
        removeNotificationFromStream(stream);
    }

    private Map<String, Object> getParametersNotification(String severity){
        final LoggingAlertConfig configGeneral = clusterConfigService.getOrDefault(LoggingAlertConfig.class,
                LoggingAlertConfig.createDefault());

        Map<String, Object> parametersNotification = Maps.newHashMap();
        parametersNotification.put(AlertRuleUtils.SEVERITY, severity);
        parametersNotification.put(AlertRuleUtils.CONTENT, configGeneral.accessLogBody());
        parametersNotification.put(AlertRuleUtils.SPLIT_FIELDS, Collections.emptyList());
        parametersNotification.put(AlertRuleUtils.AGGREGATION_TIME, configGeneral.accessAggregationTime());
        parametersNotification.put(AlertRuleUtils.LIMIT_OVERFLOW, configGeneral.accessLimitOverflow());
        parametersNotification.put(AlertRuleUtils.COMMENT, AlertRuleUtils.COMMENT_ALERT_WIZARD);

        return parametersNotification;
    }

    private String createNotification(String streamID, CreateAlarmCallbackRequest cacr, String userName){
        try {
            final AlarmCallbackConfiguration alarmCallbackConfiguration =
                    alarmCallbackConfigurationService.create(streamID, cacr, userName);
            alarmCallbackFactory.create(alarmCallbackConfiguration).checkConfiguration();
            return alarmCallbackConfigurationService.save(alarmCallbackConfiguration);
        } catch (ValidationException | AlarmCallbackConfigurationException | ConfigurationException e) {
            LOG.error(ERROR_ALARM_CALLBACK_CONFIGURATION, e);
        } catch (ClassNotFoundException e) {
            LOG.error(ERROR_ALARM_CALLBACK_TYPE, e);
        }
        return null;
    }

    public String createNotificationFromParameters(String title, Stream stream, Map<String, Object> parameters, String userName){
        CreateAlarmCallbackRequest cacr = CreateAlarmCallbackRequest.create(AlertRuleUtils.TYPE_LOGGING_ALERT, title, parameters);
        return createNotification(stream.getId(), cacr, userName);
    }

    public String createNotificationFromConfiguration(String title, Stream stream, AlarmCallbackConfiguration alarmCallbackConfig, String userName){
        final AlarmCallbackConfiguration updatedAlarmCallbackConfig = ((AlarmCallbackConfigurationImpl) alarmCallbackConfig).toBuilder()
                .setTitle(title)
                .build();
        final CreateAlarmCallbackRequest cacr = CreateAlarmCallbackRequest.create(updatedAlarmCallbackConfig);
        return createNotification(stream.getId(), cacr, userName);
    }

    public String createDefaultNotification(String title, Stream stream, String severity, String userName){
        if(alertRuleUtils.isValidSeverity(severity)){
            return createNotificationFromParameters(title, stream, getParametersNotification(severity), userName);
        }
        return null;
    }

    public boolean updateNotification(String title, String notificationID, String severity) {
        if(alertRuleUtils.isValidSeverity(severity)){
            try {
                final AlarmCallbackConfiguration callbackConfiguration = alarmCallbackConfigurationService.load(notificationID);
                if (callbackConfiguration != null) {
                    Map<String, Object> configuration = callbackConfiguration.getConfiguration();
                    configuration.replace(AlertRuleUtils.SEVERITY, severity);
                    final AlarmCallbackConfiguration updatedConfig = ((AlarmCallbackConfigurationImpl) callbackConfiguration).toBuilder()
                            .setTitle(title)
                            .setConfiguration(configuration)
                            .build();

                    alarmCallbackFactory.create(updatedConfig).checkConfiguration();
                    alarmCallbackConfigurationService.save(updatedConfig);
                }
                return true;
            } catch (ValidationException | AlarmCallbackConfigurationException | ConfigurationException e) {
                LOG.error(ERROR_ALARM_CALLBACK_CONFIGURATION, e);
            } catch (ClassNotFoundException e) {
                LOG.error(ERROR_ALARM_CALLBACK_TYPE, e);
            }
        }
        return false;
    }

    public String createCondition(String conditionType ,String alertTitle, Map<String, Object>  parameters, Stream conditionStream, Stream stream2, String userName){
        CreateConditionRequest ccr = CreateConditionRequest.create(conditionType, alertTitle, parameters);
        AlertCondition alertCondition;
        try {
            alertCondition = alertService.fromRequest(ccr, conditionStream, userName);
            streamService.addAlertCondition(conditionStream, alertCondition);
            return alertCondition.getId();
        } catch (ConfigurationException | ValidationException e) {
            cleanAlertRule(conditionStream, stream2);
            LOG.error(ERROR_ALARM_CONDITION_CONFIGURATION, e);
            throw new BadRequestException(e.getMessage(), e);
        }
    }

    public void createUniqueLookup(CacheDto cache, DataAdapterDto adapter) {

        final Collection<LookupTableDto> tables = dbTableService.findAll();
        for (LookupTableDto lookupTableDto:tables) {
            if (lookupTableDto.title().equals("wizard lookup")) {
                return;
            }
        }

        LookupTableDto dto = LookupTableDto.builder()
                .title("wizard lookup")
                .description(DESCRIPTION)
                .name("wizard_lookup")
                .cacheId(cache.id())
                .dataAdapterId(adapter.id())
                .defaultSingleValue("")
                .defaultSingleValueType(LookupDefaultSingleValue.Type.NULL)
                .defaultMultiValue("")
                .defaultMultiValueType(LookupDefaultMultiValue.Type.NULL)
                .build();

        dbTableService.save(dto);
    }

    public CacheDto createUniqueCache() {
        final Collection<CacheDto> caches = dbCacheService.findAll();
        for (CacheDto cacheDto:caches) {
            if(cacheDto.title().equals("wizard cache")){
                return cacheDto;
            }
        }

        final String cacheID = RandomStringUtils.random(RANDOM_COUNT, RANDOM_CHARS);

        NullCache.Config config = NullCache.Config.builder()
                .type("none")
                .build();

        CacheDto dto = CacheDto.builder()
                .id(cacheID)
                .name("wizard-cache")
                .description(DESCRIPTION)
                .title("wizard cache")
                .config(config)
                .build();

        return dbCacheService.save(dto);
    }

    public DataAdapterDto createUniqueDataAdapter(String userName) {

        final Collection<DataAdapterDto> adapters = dbDataAdapterService.findAll();
        for (DataAdapterDto dataAdapters:adapters) {
            if (dataAdapters.title().equals("Wizard data adapter")){
                return dataAdapters;
            }
        }

        Map<String, String> headers = new HashMap<>();
        headers.put("Authorization", "Basic user:password(base64)");

        final String adapterID = RandomStringUtils.random(RANDOM_COUNT, RANDOM_CHARS);
        final String url = httpConfiguration.getHttpPublishUri().resolve(HttpConfiguration.PATH_API).toString() + "plugins/com.airbus_cyber_security.graylog/lists/${key}";

        HTTPJSONPathDataAdapter.Config config = HTTPJSONPathDataAdapter.Config.builder()
                .type("")
                .url(url)
                .singleValueJSONPath("$.lists.lists")
                .multiValueJSONPath("$.lists.lists")
                .userAgent(userName)
                .headers(headers)
                .build();

        DataAdapterDto dto = DataAdapterDto.builder()
                .id(adapterID)
                .title("Wizard data adapter")
                .description(DESCRIPTION)
                .name("wizard-data-adapter")
                .contentPack(null)
                .config(config)
                .build();

        return dbDataAdapterService.save(dto);
    }

    public List<FieldRuleImpl> extractPipelineFieldRules(List<FieldRuleImpl> listFieldRule){
        List<FieldRuleImpl> listPipelineFieldRule = new ArrayList<>();
        for (FieldRuleImpl fieldRule : listFieldRule) {
            if (fieldRule.getType() == 7 || fieldRule.getType() == -7) {
                listPipelineFieldRule.add(fieldRule);
            }
        }
        return listPipelineFieldRule;
    }

    public EventProcessorConfig createCorrelationCondition(String type, String streamID, String streamID2, Map<String, Object> conditionParameter){
        String messsageOrder;
        if(type.equals("THEN")){
            messsageOrder = "AFTER";
        }else{
            messsageOrder = "ANY";
        }

        return CorrelationCountProcessorConfig.builder()
                .stream(streamID)
                .thresholdType((String) conditionParameter.get("threshold_type"))
                .threshold((int) conditionParameter.get("threshold"))
                .additionalStream(streamID2)
                .additionalThresholdType((String) conditionParameter.get("additional_threshold_type"))
                .additionalThreshold((int) conditionParameter.get("additional_threshold"))
                .messagesOrder(messsageOrder)
                .searchWithinMs(((int) conditionParameter.get("time")) * 60 * 1000)
                .executeEveryMs(((int) conditionParameter.get("grace")) * 60 * 1000)
                .groupingFields(new HashSet<String>((List<String>) conditionParameter.get("grouping_fields")))
                .comment(AlertRuleUtils.COMMENT_ALERT_WIZARD)
                .searchQuery("*")
                .build();
    }

    public EventProcessorConfig createAggregationCondition(String streamID, Map<String, Object> conditionParameter){
        return AggregationCountProcessorConfig.builder()
                .stream(streamID)
                .thresholdType((String) conditionParameter.get("threshold_type"))
                .threshold((int) conditionParameter.get("threshold"))
                .searchWithinMs(((int) conditionParameter.get("time")) * 60 * 1000)
                .executeEveryMs(((int) conditionParameter.get("grace")) * 60 * 1000)
                .groupingFields(new HashSet<String>((List<String>) conditionParameter.get("grouping_fields")))
                .distinctionFields(new HashSet<String>((List<String>) conditionParameter.get("distinction_fields")))
                .comment(AlertRuleUtils.COMMENT_ALERT_WIZARD)
                .searchQuery("*")
                .build();
    }

    public EventProcessorConfig createStatisticalCondition(String streamID, Map<String, Object> conditionParameter){
        LOG.info("Begin Stat, type: " + conditionParameter.get("type"));
        AggregationFunction agregationFunction;
        switch (conditionParameter.get("type").toString()) {
            case "MEAN":
                agregationFunction = AggregationFunction.AVG;
                break;
            case "MIN":
                agregationFunction = AggregationFunction.MIN;
                break;
            case "MAX":
                agregationFunction = AggregationFunction.MAX;
                break;
            case "SUM":
                agregationFunction = AggregationFunction.SUM;
                break;
            case "STDDEV":
                agregationFunction = AggregationFunction.STDDEV;
                break;
            default:
                throw new BadRequestException();
        }

        String ID = UUID.randomUUID().toString();
        final AggregationSeries serie = AggregationSeries.builder()
                .id(ID)
                .function(agregationFunction)
                .field(conditionParameter.get("field").toString())
                .build();

        final Expr.NumberReference left = Expr.NumberReference.create(ID);
        final Expr.NumberValue right = Expr.NumberValue.create((int) conditionParameter.get("threshold"));
        final Expression<Boolean> expression;
        switch (conditionParameter.get("threshold_type").toString()) {
            case ">":
                expression = Expr.Greater.create(left, right);
                break;
            case ">=":
                expression = Expr.GreaterEqual.create(left, right);
                break;
            case "<":
                expression = Expr.Lesser.create(left, right);
                break;
            case "<=":
                expression = Expr.LesserEqual.create(left, right);
                break;
            case "=":
                expression = Expr.Equal.create(left, right);
                break;
            default:
                throw new BadRequestException();
        }

        return AggregationEventProcessorConfig.builder()
                .query("")
                .streams(new HashSet<String> (Collections.singleton(streamID)))
                .series(ImmutableList.of(serie))
                .groupBy(ImmutableList.of())
                .conditions(AggregationConditions.builder()
                        .expression(expression)
                        .build())
                .executeEveryMs(((int) conditionParameter.get("grace")) * 60 * 1000)
                .searchWithinMs(((int) conditionParameter.get("time")) * 60 * 1000)
                .build();
    }

    public String createNotification(String alertTitle, String severity){
        LoggingNotificationConfig loggingNotificationConfig = LoggingNotificationConfig.builder()
                .singleMessage(false)
                .severity(SeverityType.valueOf(severity.toUpperCase()))
                .logBody("Test")
                .build();
        NotificationDto notification = NotificationDto.builder()
                .config(loggingNotificationConfig)
                .title(alertTitle)
                .description(AlertRuleUtils.COMMENT_ALERT_WIZARD)
                .build();
        notification = this.notificationResourceHandler.create(notification);
        return notification.id();
    }

    public String createEvent(String alertTitle, String notificationID, EventProcessorConfig configuration){
        EventNotificationHandler.Config notificationConfiguration = EventNotificationHandler.Config.builder()
                .notificationId(notificationID)
                .build();

        EventDefinitionDto eventDefinition = EventDefinitionDto.builder()
                .title(alertTitle)
                .description(AlertRuleUtils.COMMENT_ALERT_WIZARD)
                //.description(request.getDescription())
                .config(configuration)
                .alert(true)
                .priority(2)
                .keySpec(ImmutableList.of())
                .notifications(ImmutableList.<EventNotificationHandler.Config>builder().add(notificationConfiguration).build())
                .notificationSettings(EventNotificationSettings.builder()
                        .gracePeriodMs(0L)
                        .backlogSize(500)
                        .build())
                .build();

        //TODO do it with eventDefinitionsResource to have the validation but need to get the event ID back
        //this.eventDefinitionsResource.create(eventDefinition);
        eventDefinition = this.eventDefinitionHandler.create(eventDefinition);
        return eventDefinition.id();
    }

}
